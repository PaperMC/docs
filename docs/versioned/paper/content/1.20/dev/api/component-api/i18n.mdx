---
slug: /dev/component-api/i18n
description: How to use Adventure's internationalization.
title: Internationalization
---

Generally it's a good idea to support translations in your plugin, especially if you want to
appeal to the largest user base. Adventure makes this simple by adding a server-side
translation layer to almost all text that ends up being displayed to clients.

:::info[Javadocs]

Adventure's Javadocs for all-things translations can be found [here](https://jd.advntr.dev/api/latest/net/kyori/adventure/translation/package-summary.html).

:::

## GlobalTranslator

All translation is done through [`GlobalTranslator`](https://jd.advntr.dev/api/latest/net/kyori/adventure/translation/GlobalTranslator.html).
You can render translations yourself and add new sources for translations.

You can add sources to the `GlobalTranslator` by creating instances of [`TranslationRegistry`](https://jd.advntr.dev/api/latest/net/kyori/adventure/translation/TranslationRegistry.html)
or implementing the [`Translator`](https://jd.advntr.dev/api/latest/net/kyori/adventure/translation/Translator.html) interface yourself.

## Where translations work

Vanilla Minecraft handles translations on the client by using the language files bundled with the client or provided via resource packs. If you don't want to send custom language files
in a resource pack, server-side translations are the only alternative. They work anywhere the component API exists, except for <Javadoc name={"org.bukkit.inventory.ItemStack"}>`ItemStack`</Javadoc>
display text like the display name or lore. So chat, entity display names, scoreboards, tab lists, etc., all support translations.

:::caution

The player's language as declared in the settings packet sent by the client arrives **after** the player has joined the server, so there are no guarantees that
translations will work for a client that is joining during the <Javadoc name={"org.bukkit.event.player.PlayerJoinEvent"}>`PlayerJoinEvent`</Javadoc> or any earlier event.
You can listen for the first <Javadoc name={"com.destroystokyo.paper.event.player.PlayerClientOptionsChangeEvent"}>`PlayerClientOptionsChangeEvent`</Javadoc>
after joining to know with 100% certainty what language the client that joined is using.

:::

## Examples

### `ResourceBundle`
```properties title="src/main/resources/your/plugin/Bundle_en_US.properties"
some.translation.key=Translated Message: {0}
```

```java
TranslationRegistry registry = TranslationRegistry.create(Key.key("namespace:value"));

ResourceBundle bundle = ResourceBundle.getBundle("your.plugin.Bundle", Locale.US, UTF8ResourceBundleControl.get());
registry.registerAll(Locale.US, bundle, true);
GlobalTranslator.translator().addSource(registry);
```

This creates a new `TranslationRegistry` under a specified namespace. Then, a <Javadoc name={"java.util.ResourceBundle"} project={"java"}>`ResourceBundle`</Javadoc>
is created from a bundle located on the classpath with the specified <Javadoc name={"java.util.Locale"} project={"java"}>`Locale`</Javadoc>.
Finally, that `ResourceBundle` is added to the registry. That registry is then added as a source to the `GlobalTranslator`.
This makes all the translations available server-side.

Now you can use translation keys in translatable components.

```java
final Component message = Component.translatable("some.translation.key", Component.text("The Argument"))
```

This will show to clients using the US English language: `Translated Message: The Argument`.
