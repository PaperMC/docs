---
slug: /dev/command-api/minecraft-arguments
description: Everything regarding the arguments retrievable from the ArgumentTypes class
---

import BlockPositionMp4 from "./assets/vanilla-arguments/blockposition.mp4"
import BlockStateMp4 from "./assets/vanilla-arguments/blockstate.mp4"
import ComponentMp4 from "./assets/vanilla-arguments/component.mp4"
import DoubleRangeMp4 from "./assets/vanilla-arguments/doublerange.mp4"
import EntityOppedMp4 from "./assets/vanilla-arguments/entity-opped.mp4"
import EntityUnoppedMp4 from "./assets/vanilla-arguments/entity-unopped.mp4"
import EntitiesMp4 from "./assets/vanilla-arguments/entities.mp4"

# Minecraft arguments
The [Arguments and Literals](./arguments-and-literals) page covers the most used, native Brigadier arguments. But Minecraft (and Paper) defines a few more. These can be accessed
in a static context using the `ArgumentTypes` class. We will go over all of those here.

## Quick overview
You might as well use this a quick reference or a table of contents. The arguments are explained in more detail after this table:

|               Method Name               |          Return Value          |                             Quick Link                             |
|-----------------------------------------|--------------------------------|--------------------------------------------------------------------|
| `blockPosition()`                       | BlockPositionResolver          | [blockPosition argument](#blockposition-argument)                  |
| `blockState()`                          | BlockState                     | [blockState argument](#blockstate-argument)                        |
| `component()`                           | Component (Kyori)              | [component argument](#component-argument)                          |
| `doubleRange()`                         | DoubleRangeProvider            | [doubleRange argument](#doublerange-argument)                      |
| `entity()`                              | EntitySelectorArgumentResolver | [entity argument](#entity-argument)                                |
| `entities()`                            | EntitySelectorArgumentResolver | [entities argument](#entities-argument)                            |
| `entityAnchor()`                        | LookAnchor                     | [entityAnchor argument](#entityanchor-argument)                    |
| `finePosition()`                        | FinePositionResolver           | [finePosition argument](#fineposition-argument)                    |
| `finePosition(boolean centerIntegers)`  | FinePositionResolver           | [finePosition argument](#fineposition-argument)                    |
| `gameMode()`                            | GameMode                       | [gameMode argument](#gamemode-argument)                            |
| `heightMap()`                           | HeightMap                      | [heightMap argument](#heightmap-argument)                          |
| `integerRange()`                        | IntegerRangeProvider           | [integerRange argument](#integerrange-argument)                    |
| `itemPredicate()`                       | ItemStackPredicate             | [itemPredicate argument](#itempredicate-argument)                  |
| `itemStack()`                           | ItemStack                      | [itemStack argument](#itemstack-argument)                          |
| `key()`                                 | Key (Kyori)                    | [key argument](#key-argument)                                      |
| `namedColor()`                          | NamedTextColor (Kyori)         | [namedColor argument](#namedcolor-argument)                        |
| `namespacedKey()`                       | NamespacedKey (Bukkit)         | [namespacedKey argument](#namespacedkey-argument)                  |
| `objectiveCriteria()`                   | Criteria                       | [objectiveCriteria argument](#objectivecriteria-argument)          |
| `player()`                              | PlayerSelectorArgumentResolver | [player argument](#player-argument)                                |
| `players()`                             | PlayerSelectorArgumentResolver | [players argument](#players-argument)                              |
| `playerProfiles()`                      | PlayerProfileListResolver      | [playerProfiles argument](#playerprofiles-argument)                |
| `resource(RegistryKey)`                 | (Depends on RegistryKey)       | [resource argument](#resource-argument)                            |
| `resourceKey(RegistryKey)`              | (Depends on RegistryKey)       | [resourceKey argument](#resourcekey-argument)                      |
| `style()`                               | Style (Kyori)                  | [style argument](#style-argument)                                  |
| `signedMessage()`                       | SignedMessageResolver          | [signedMessage argument](#signedmessage-argument)                  |
| `scoreboardDisplaySlot()`               | DisplaySlot                    | [scoreboardDisplaySlot argument](#scoreboarddisplayslot-argument)  |
| `time()`                                | Integer                        | [time argument](#time-argument)                                    |
| `templateMirror()`                      | Mirror                         | [templateMirror argument](#templatemirror-argument)                |
| `templateRotation()`                    | StructureRotation              | [templateRotation argument](#templaterotation-argument)            |
| `uuid()`                                | UUID                           | [uuid argument](#uuid-argument)                                    |
| `world()`                               | World                          | [world argument](#world-argument)                                  |


## blockPosition argument
The block position argument is used for retrieving the position of a block. It works the same way as the first argument of the `/setblock <position> <block>` vanilla command.
In order to retrieve the BlockPosition variable from the `BlockPositionResolver`, we have to resolve it using the command source.

### Example usage
```java
public static LiteralCommandNode<CommandSourceStack> blockPositionArgument() {
    return Commands.literal("blockpositionargument")
        .then(Commands.argument("arg", ArgumentTypes.blockPosition())
            .executes(ctx -> {
                final BlockPositionResolver blockPositionResolver = ctx.getArgument("arg", BlockPositionResolver.class);
                final BlockPosition blockPosition = blockPositionResolver.resolve(ctx.getSource());

                ctx.getSource().getSender().sendMessage("Put in " + blockPosition.x() + " " + blockPosition.y() + " " + blockPosition.z());
                return Command.SINGLE_SUCCESS;
            }))
        .build();
}
```

### In-game preview
<FullWidthVideo src={BlockPositionMp4}/>

## blockState argument
The block state argument is a very useful argument for getting use input on an exact block type and its data. It is particularly useful for commands that modify blocks
in some way, which requires precise input.

### Example usage
```java
public static LiteralCommandNode<CommandSourceStack> blockStateArgument() {
    return Commands.literal("blockstateargument")
        .then(Commands.argument("arg", ArgumentTypes.blockState())
            .executes(ctx -> {
                final BlockState blockState = ctx.getArgument("arg", BlockState.class);
                
                ctx.getSource().getSender().sendMessage("You specified a " + blockState.getType() + "!");
                return Command.SINGLE_SUCCESS;
            }))
        .build();
}
```

### In-game preview
<FullWidthVideo src={BlockStateMp4}/>


## component argument
The component argument is a very complicated command for the user, which is why it should not be used for usual user input. It follows the same format as the `/tellraw <player> <msg>`
command for its second argument. It accepts a text component as its json representation, returning it as an Adventure component to work with.

### Example usage
```java
public static LiteralCommandNode<CommandSourceStack> componentArgument() {
    return Commands.literal("componentargument")
        .then(Commands.argument("arg", ArgumentTypes.component())
            .executes(ctx -> {
                final Component component = ctx.getArgument("arg", Component.class);

                ctx.getSource().getSender().sendRichMessage(
                    "Your message: <input>",
                    Placeholder.component("input", component)
                );
                return Command.SINGLE_SUCCESS;
            }))
        .build();
}
```

### In-game preview
<FullWidthVideo src={ComponentMp4}/>


## doubleRange argument
The double range argument is another very niche argument. With it you can define a double, or a range/amount of doubles, which can act as a predicate for numbers. This
could be used for an argument which kill all enemies in a specific range or for clearing items in a range of slots. As this argument is also rather technical, it is
not used very often.

### Example usage
```java
public static LiteralCommandNode<CommandSourceStack> doubleRange() {
    return Commands.literal("doublerange")
        .then(Commands.argument("arg", ArgumentTypes.doubleRange())
            .executes(ctx -> {
                final DoubleRangeProvider doubleRangeProvider = ctx.getArgument("arg", DoubleRangeProvider.class);
                final CommandSender sender = ctx.getSource().getSender();

                for (int i = 0; i < 5; i++) {
                    sender.sendRichMessage("Is <index> in bounds? <result>",
                        Placeholder.unparsed("index", Integer.toString(i)),
                        Placeholder.unparsed("result", Boolean.toString(doubleRangeProvider.range().test((double) i)))
                    );
                }
                return Command.SINGLE_SUCCESS;
            }))
        .build();
}
```

### In-game preview
<FullWidthVideo src={DoubleRangeMp4}/>


## entity argument
The entity argument has some strange behavior. If the executing sender is opped, they have access to not only players as valid arguments, but also entity selectors (like `@e` or `@r`).
Though if the executing sender is not opped, they do not have access to entity selectors. Due to this mechanic, it is suggested to only use this argument if you are sure that
the executing sender has operator permissions. This could be achieve with a `.requires(ctx -> ctx.getSender().isOp())` predicate on the command root.

This argument, after resolving its `EntitySelectorArgumentResolver` returns a list of exactly one, no more and no less, Entities. It is safe to call `List#getFirst()` to retrieve that
entity. 

### Example usage
```java
public static LiteralCommandNode<CommandSourceStack> entity() {
    return Commands.literal("entityarg")
        .requires(ctx -> ctx.getSender().isOp())
        .then(Commands.argument("arg", ArgumentTypes.entity())
            .executes(ctx -> {
                final EntitySelectorArgumentResolver entitySelectorArgumentResolver = ctx.getArgument("arg", EntitySelectorArgumentResolver.class);
                final List<Entity> entities = entitySelectorArgumentResolver.resolve(ctx.getSource());

                ctx.getSource().getSender().sendRichMessage("Found a <entitytype>",
                    Placeholder.unparsed("entitytype", entities.getFirst().getType().name())
                );
                return Command.SINGLE_SUCCESS;
            }))
        .build();
}
```

### In-game preview
If the executing player is not opped:
<FullWidthVideo src={EntityUnoppedMp4}/>

If the executing player is opped:
<FullWidthVideo src={EntityOppedMp4}/>


## entities argument
Similar to the single entity argument, this argument also requires the executing sender to be opped in order to view useful suggestions.

In contrast to the single entity argument, this multi entity argument accepts any amount of entities, with the minimum amount of entities being 1.
They can, once again, be resolved using `EntitySelectorArgumentResolver#resolve(CommandSourceStack)`, which returns a `List<Entity>`.

### Example usage
```java
public static LiteralCommandNode<CommandSourceStack> entities() {
    return Commands.literal("entitiesarg")
        .requires(ctx -> ctx.getSender().isOp())
        .then(Commands.argument("arg", ArgumentTypes.entities())
            .executes(ctx -> {
                final EntitySelectorArgumentResolver entitySelectorArgumentResolver = ctx.getArgument("arg", EntitySelectorArgumentResolver.class);
                final List<Entity> entities = entitySelectorArgumentResolver.resolve(ctx.getSource());

                ctx.getSource().getSender().sendRichMessage("Found the following entities: <entitytypes>",
                    Placeholder.unparsed("entitytypes", String.join(", ", entities.stream().map(Entity::getType).map(EntityType::name).toList()))
                );
                return Command.SINGLE_SUCCESS;
            }))
        .build();
}
```

## In-game preview
<FullWidthVideo src={EntitiesMp4}/>


## entityAnchor argument


## finePosition argument


## finePosition argument


## gameMode argument


## heightMap argument


## integerRange argument


## itemPredicate argument


## itemStack argument


## key argument


## namedColor argument


## namespacedKey argument


## objectiveCriteria argument


## player argument


## players argument


## playerProfiles argument


## resource argument


## resourceKey argument


## style argument


## signedMessage argument


## scoreboardDisplaySlot argument


## time argument


## templateMirror argument


## templateRotation argument


## uuid argument


## world argument

