---
title: Particles
description: Comprehensive guide to particle spawning
slug: paper/dev/particles
version: "1.21.5"
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';

This guide explains how to spawn different types of particles.

There are two ways to spawn particles.
The first option is using the [`ParticleBuilder`](jd:paper:com.destroystokyo.paper.ParticleBuilder) class, which is
preferred over the `spawnParticle()` methods. It is reusable and offers improved readability and clarity. The builder also includes
the method [`receivers()`](jd:paper:com.destroystokyo.paper.ParticleBuilder#receivers()), which provides you
with greater control over receivers.

An example of spawning 14 note particles in a 4x0.4x4 cuboid:
```java
new ParticleBuilder(Particle.NOTE)
  .location(someLocation)
  .offset(2, 0.2, 2)
  .count(14)
  .receivers(48, true)
  .spawn();
```

:::note
This guide uses [`ParticleBuilder.receivers(48, true)`](jd:paper:com.destroystokyo.paper.ParticleBuilder#receivers(int,boolean))
which selects players that have a distance of up to 48 blocks (3 chunks) from the particle's location.
:::

The second way is using the `spawnParticle()` methods in `World` and `Player` classes:
- [`World.spawnParticle()`](jd:paper:org.bukkit.World#spawnParticle(org.bukkit.Particle,double,double,double,int)) which spawns the particle for all players and
- [`Player.spawnParticle()`](jd:paper:org.bukkit.entity.Player#spawnParticle(org.bukkit.Particle,double,double,double,int)) which spawns the particle only for the player.

:::note
`offset` arguments are multiplied by a Gaussian (normal) distribution's random value (if offset arguments are used for offset).
In simple terms this means an offset can be **added to** OR **subtracted from** the supplied location/coordinates.
This also means that more particles will spawn closer to the supplied location.
<details>
  <summary>Example</summary>
If we have a `location` and set offset arguments to `0.5, 0.5, 1.5`, particles will randomly spawn between coordinates
`location.subtract(0.5, 0.5, 1.5)` and `location.add(0.5, 0.5, 1.5)`, or simply, inside a `1x1x3` box where `location` is
the center.
</details>
:::

:::note
If the particle you're trying to spawn isn't mentioned in this guide, then it most likely has no special behavior.
:::

## Directional particles
This type of particle has an initial velocity when spawned. The velocity can be determined in two different ways, however
both take into account the `extra` argument as speed.

:::note
Effective speed varies between particles.
:::

In the following example 8 flame particles are spawned in a 1x1x1 cube shape randomly, with `someLocation` serving as it's center.
The last argument (extra) is set to 0, so the particles don't move.
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.FLAME)
      .location(someLocation)
      .offset(0.5, 0.5, 0.5)
      .count(8)
      .extra(0)
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.FLAME, someLocation, 8, 0.5, 0.5, 0.5, 0);
    ```
  </TabItem>
</Tabs>

:::caution
Leaving the `extra` parameter unset will default it to `1` (used as particle speed),
likely resulting in unexpected behavior.
:::

### Random direction
Setting the `count` parameter to anything positive will yield a random direction for the velocity. The offset arguments are used as a random
spawn offset from the location.

An example of spawning 6 CRIT particles at a location, without offset, that will move in a random direction at a slow speed:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.CRIT)
      .location(someLocation)
      .count(6)
      .extra(0.12)
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.CRIT, someLocation, 6, 0, 0, 0, 0.12);
    ```
  </TabItem>
</Tabs>

### Specified direction
To specify the velocity's direction, set the `count` argument to `0` and use the offset arguments as the direction vector.
The `extra` argument will serve as the vector's multiplier, scaling it.

So for example if we set offsets to `2.5, 1.2, 0.4` and `extra` to `5`, the final velocity vector would be `(12.5, 6, 2)`.

An example of a repeating task spawning campfire smoke that slowly goes "up" (positive Y axis):
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    ParticleBuilder particleBuilder = new ParticleBuilder(Particle.CAMPFIRE_SIGNAL_SMOKE)
      .location(someLocation)
      .offset(0, 1, 0)
      .count(0)
      .extra(0.1);

    Bukkit.getScheduler().runTaskTimer(plugin,
      () -> particleBuilder.receivers(48, true).spawn(),
    0, 4);
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    Bukkit.getScheduler().runTaskTimer(plugin,
      () -> someWorld.spawnParticle(Particle.CAMPFIRE_SIGNAL_SMOKE, someLocation, 0, 0, 1, 0, 0.1),
      0, 4);
    ```
  </TabItem>
</Tabs>
We could also make the smoke go down if we wanted to:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    ParticleBuilder particleBuilder = new ParticleBuilder(Particle.CAMPFIRE_SIGNAL_SMOKE)
      .location(someLocation)
      .offset(0, -1, 0)
      .count(0)
      .extra(0.1)
      .receivers(48, true);

    Bukkit.getScheduler().runTaskTimer(plugin,
      () -> particleBuilder.receivers(48, true).spawn(),
    0, 4);
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    Bukkit.getScheduler().runTaskTimer(plugin,
      () -> someWorld.spawnParticle(Particle.CAMPFIRE_SIGNAL_SMOKE, someLocation, 0, 0, -1, 0, 0.1),
      0, 4);
    ```
  </TabItem>
</Tabs>

{/* spellchecker:off */}
### List of directional particles
<details>
<summary>Show list</summary>
- BLOCK,
- BUBBLE,
- BUBBLE_COLUMN_UP,
- CAMPFIRE_COSY_SMOKE,
- CAMPFIRE_SIGNAL_SMOKE,
- CLOUD,
- CRIT,
- DAMAGE_INDICATOR,
- DRAGON_BREATH,
- DUST_PLUME,
- ELECTRIC_SPARK,
- ENCHANTED_HIT,
- END_ROD,
- FIREWORK,
- FLAME,
- FLASH,
- GLOW_SQUID_INK,
- ITEM,
- LARGE_SMOKE,
- POOF,
- REVERSE_PORTAL,
- SCRAPE,
- SCULK_CHARGE,
- SCULK_CHARGE_POP,
- SCULK_SOUL,
- SHRIEK,
- SMALL_FLAME,
- SMOKE,
- SNEEZE,
- SNOWFLAKE,
- SOUL,
- SOUL_FIRE_FLAME,
- SPIT,
- SPLASH,
- SQUID_INK,
- TOTEM_OF_UNDYING,
- TRIAL_SPAWNER_DETECTION,
- TRIAL_SPAWNER_DETECTION_OMINOUS,
- WAX_OFF,
- WAX_ON,
- WHITE_SMOKE.

</details>
{/* spellchecker:on */}

## Colored particles
These particles can be colored by passing a [`Color`](jd:paper:org.bukkit.Color) object as the `data` argument.

Example of spawning 10 potion effect particles in a 2x2x2 area with a slightly translucent orange color:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.ENTITY_EFFECT)
      .location(someLocation)
      .offset(1, 1, 1)
      .count(10)
      .data(Color.fromARGB(200, 255, 128, 0))
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.ENTITY_EFFECT, someLocation, 10, 1, 1, 1, Color.fromARGB(200, 255, 128, 0));
    ```
  </TabItem>
</Tabs>

:::note
Colored particles support the alpha channel, which means you can make them translucent. The exceptions are [dust](#dust-particles),
[dust transition](#dust-transition-particles), [note](#note-particles) and [trail](#trail-particles) particles, which do
not support the alpha channel.
:::

:::note
The `EFFECT` particle can not be colored and will always be white, use `ENTITY_EFFECT` instead.
:::

### Dust particles
The only Vanilla dust particle is the redstone particle. However, you can easily create a custom colored one by passing
[Particle.DustOptions](jd:paper:org.bukkit.Particle$DustOptions) as `data`.

An example of creating a vertical line of green dust particles:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    ParticleBuilder particleBuilder = new ParticleBuilder(Particle.DUST)
      .count(1)
      .color(Color.GREEN, 1.0f)
      .receivers(48, true);

    // We can reuse the builder
    for (double i = 0; i <= 1.0; i += 0.1) {
      particleBuilder.location(someLocation.clone().add(0, i, 0)).spawn();
    }
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    for (double i = 0; i <= 1.0; i += 0.1) {
      someWorld.spawnParticle(
        Particle.DUST,
        someLocation.clone().add(0, i, 0),
        1,
        new Particle.DustOptions(Color.GREEN, 1.0f)
      );
    }
    ```
  </TabItem>
</Tabs>

:::note
The size argument also controls the dust particle's lifetime:
> The particle's lifetime is a random integer from 8 to 40 game ticks, then multiplied by this scale value, with a minimum of 1.

*According to the Minecraft wiki*
:::

### Dust transition particles
Dust transition particles work similarly to [dust particles](#dust-particles), but they **transition** their color
from one to another. This can be achieved by passing [Particle.DustTransition](jd:paper:org.bukkit.Particle$DustTransition)
as `data`.

An example where 3 dust transition particles spawn on the x-axis within a 1 block length:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.DUST_COLOR_TRANSITION)
      .location(someLocation)
      .offset(1, 0, 0)
      .count(3)
      .colorTransition(Color.RED, Color.BLUE, 1.0f)
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(
      Particle.DUST_COLOR_TRANSITION,
      someLocation,
      3,
      0.5, 0, 0,
      new Particle.DustTransition(Color.RED, Color.BLUE, 1.0f)
    );
    ```
  </TabItem>
</Tabs>

### Note particles
The note particles have two different behaviors based on the `count` argument.
- If set to a positive number a random color
(of the preset 24) will be chosen for each spawned particle.
- If set to `0`, the `offsetX` argument will be used as a substitution to a **HSB (hue, saturation, brightness)** color format's
hue value, which has a starting point at a green color.

Example:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.NOTE)
      .location(someLocation)
      .offset(0, 0.4f, 0)
      .count(0)
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.NOTE, someLocation, 0, 0.4f, 0, 0);
    ```
  </TabItem>
</Tabs>

:::tip
To achieve the Vanilla note particle colors you must set the offsetX to a fraction of 24.

Example:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.NOTE)
      .location(someLocation)
      .offset(2.0f/24.0f, 0, 0)
      .count(0)
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.NOTE, someLocation, 0, 2.0f/24.0f, 0, 0);
    ```
  </TabItem>
</Tabs>
:::

### Trail particles
Trail particles require you to pass a [`Particle.Trail`](jd:paper:org.bukkit.Particle$Trail) object as `data`.

An example where 8 randomly offset trail particles move towards `someLocation`, which is in the center of the spawning
bounding box in 10 ticks:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.TRAIL)
      .location(someLocation)
      .offset(2, 2, 2)
      .count(8)
      .data(new Particle.Trail(someLocation, Color.RED, 10))
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(
      Particle.TRAIL,
      someLocation,
      8,
      2, 2, 2,
      new Particle.Trail(someLocation, Color.RED, 10)
    );
    ```
  </TabItem>
</Tabs>


## Converging particles
As the name implies, this type of particle converges to a single point (location), which in this case is the supplied location.

The particles have two different behaviors based on the `count` argument:
- If set to a positive number, offset arguments are used normally,
- If set to `0`, the offset arguments will be used for a relative spawn location from the supplied location/coordinates.
The particle will then travel from this relative location to the supplied location in a curve.

An example where an enchantment particle will spawn at `someLocation.clone().add(2,0,2)` and travel to `someLocation`:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.ENCHANT)
      .location(someLocation)
      .offset(2, 0, 2)
      .count(0)
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.ENCHANT, someLocation, 0, 2, 0, 2);
    ```
  </TabItem>
</Tabs>

### List of converging particles
<details>
<summary>Show list</summary>
- ENCHANT,
- NAUTILUS,
- PORTAL,
- VAULT_CONNECTION.
</details>

## Material particles
### BlockData
To spawn particles that require `BlockData`, simply put `BlockData` as it's `data` argument.

Example:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.BLOCK_CRUMBLE)
      .location(someLocation)
      .count(4)
      .data(BlockType.GLOWSTONE.createBlockData())
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.BLOCK_CRUMBLE, someLocation, 4, BlockType.GLOWSTONE.createBlockData());
    ```
  </TabItem>
</Tabs>

:::note
This guide uses [`BlockType.createBlockData()`](jd:paper:org.bukkit.block.BlockType#createBlockData()). While using
[`Material.createBlockData()`](jd:paper:org.bukkit.Material#createBlockData()) or
[`Bukkit.createBlockData(Material)`](jd:paper:org.bukkit.Bukkit#createBlockData(org.bukkit.Material)) yields the same result,
they are considered **legacy**.
:::

:::tip
The `BLOCK` particle is a [directional particle](#directional-particles).

In this case **velocity matters** a lot. A higher velocity will ensure the same general direction of the particle, while a lower one will
result in a more random direction.

To achieve this, the effective velocity vector's length should be high (around 10 is fine).
:::

### ItemStack
To spawn particles that require an `ItemStack`, simply put an `ItemStack` as it's `data` argument.

Example:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.ITEM)
      .location(someLocation)
      .count(4)
      .data(ItemStack.of(Material.DIAMOND_PICKAXE))
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.ITEM, someLocation, 4, ItemStack.of(Material.DIAMOND_PICKAXE));
    ```
  </TabItem>
</Tabs>

:::note
This guide uses [`ItemStack.of(Material)`](jd:paper:org.bukkit.inventory.ItemStack#of(org.bukkit.Material)). While using
[`new ItemStack(Material)`](jd:paper:org.bukkit.inventory.ItemStack) yields the same result,
it is considered **legacy**. [`ItemType.createItemStack()`](jd:paper:org.bukkit.inventory.ItemType#createItemStack())
also yields the same result, but is more likely to get removed in the future.
:::

:::tip
The `ITEM` particle is a [directional particle](#directional-particles).
:::

## Sculk particles
### Sculk charge
The `SCULK_CHARGE` particle takes a `Float` as it's `data`. This is used as the particle's "roll". Or, more formally,
the angle the particle displays at in **radians**.

Example of spawning a sculk charge particle at 45Â°:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.SCULK_CHARGE)
      .location(someLocation)
      .count(1)
      .data(Math.toRadians(45))
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.SCULK_CHARGE, someLocation, 1, Math.toRadians(45));
    ```
  </TabItem>
</Tabs>

:::tip
The `SCULK_CHARGE` particle is a [directional particle](#directional-particles).
:::

### Shriek
The `SHRIEK` particle takes an `Integer` as its `data`. This is used to set the delay **in ticks** before the particle spawns.

It is completely up to your implementation when choosing to use `data` or a scheduler.

Example where a shriek particle will spawn after one second:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.SHRIEK)
      .location(someLocation)
      .count(1)
      .data(20)
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.SHRIEK, someLocation, 1, 20);
    ```
  </TabItem>
</Tabs>

### Vibration
Vibration particles require you to pass a [`Vibration`](jd:paper:org.bukkit.Vibration) object as `data`, where you can choose between a
location ([`Vibration.Destination.BlockDestination`](jd:paper:org.bukkit.Vibration\$Destination\$BlockDestination))
or an entity target ([`Vibration.Destination.EntityDestination`](jd:paper:org.bukkit.Vibration\$Destination\$EntityDestination)).
The constructor's second argument is the travel time in **ticks**.

An example where a vibration particle will spawn at `someLocation` and travel to `otherLocation` in 10 ticks:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    new ParticleBuilder(Particle.VIBRATION)
      .location(someLocation)
      .count(1)
      .data(new Vibration(new Vibration.Destination.BlockDestination(otherLocation), 10))
      .receivers(48, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(
      Particle.VIBRATION,
      someLocation,
      1,
      new Vibration(new Vibration.Destination.BlockDestination(otherLocation), 10)
    );
    ```
  </TabItem>
</Tabs>

## `count` argument behavior <Badge variant="danger" text="Advanced" size="large" />
When spawning particles, the Minecraft client behaves differently based on the count argument:
- If `count` is `0`, the client uses the provided location without modification. The offset values are multiplied by the
`extra` argument (acting as a speed multiplier) and passed directly to the particle constructor. The way these values are
used may vary between particle types.

- If `count` is greater than `0`, the client spawns that number of particles. For each particle, it generates random offset
values using a Gaussian (normal) distribution, multiplies them by the extra argument (as a speed multiplier), and passes
them to the particle constructor.
